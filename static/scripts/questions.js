//Loads the qualifications from S3. Runs on page load
async function loadQualification() {
    //Error checking
    ///Basic set up for all API calls. In the case of an error it generates an error bar with an appropriate message
    ///For APi calls the message is generated by the promise result
    ///In the case of page changes they are reversed in the catch statement
    try {
        ///Clears the error bar, at the beginning of all try statements - empties out any error messages since a user has made a change. Standard error checking procedure 
        clearStatusBar();

        //Variables
        ///Array containing the data pulled from the file system
        var qualifications = [];

        ///The api to be called to get the qualifications
        var api = apiRoot + "/question/filter-recall";


        //Updating the page
        ///Awaits the qualifications from the API call
        qualifications = await callGetAPI(api, "qualifications");

        ///Clears the qualification input box of any values - removes pre-set data 
        $("#qualification").empty();

        ///Adds the new data from S3 to the qualifications box
        qualifications.filters.qualifications.forEach(element => {
            $("#qualification").append(newSelectItem(element.q));
        });

        ///Runs the on change event for the qualifications box
        newQualification();
    } catch (error) {
        generateErrorBar(error);
    }
}

//Compiles an API URI for the filter function. Uses REST for a GET method
///filePath: The location of the index file to be pulled form S3
///isTopics: If the file to be pilled is for the topics, changing the file name to be selected in the function
function filterAPI(filePath, isTopics) {
    //API construction
    ///Variable to store the URI, to be passed out at the end of the function
    var uri = "";

    ///Adds the API root, the correct resource and the filepath parameter to the URI
    uri = apiRoot + "/question/filter-recall?filePath=" + filePath;

    ///If the api is to call topics then it adds the boolean variable onto the URI
    if(isTopics) {
        uri += "&topics=true";
    }

    return uri;
}

//Compiles a string containing a select item with corresponding text and value
///text: The label and the value of the option
function newSelectItem(text) {
    //String compilation
    ///Correctly formats HTML to be appended to the input box, returned at the end of the function
    var option = "<option value='" + text + "'>" + text + "</option>";

    return option
}

//Loads new exam boards from S3 based on the selected qualification. Runs on qualification change
async function newQualification() {
    try {
        clearStatusBar();

        //Variables
        ///Array containing the data pulled from the file system
        var examBoards = [];

        ///The file path of the qualification, therefore the location of the index file containing the exam boards
        userSession.filePath = encodeURIComponent($("#qualification").val()) + "/";

        ///Variable containing the api to be called for the exam boards
        var api = filterAPI(userSession.filePath, false);


        //Updating the page
        ///Awaits the API call and therefore the exam boards
        examBoards = await callGetAPI(api, "exam boards");

        ///Empties the exam board input
        $("#examBoard").empty();

        ///Puts the retrieved exam boards into the input box
        examBoards.filters.examBoards.forEach(element => {
            $("#examBoard").append(newSelectItem(element.e));
        });
            
        ///Runs the onChange for the exam board box
        newExamBoard();
    } catch (error) {
        generateErrorBar(error);
    }
}

//Loads new subjects from S3 based on the selected exam board. Runs on exam board change
async function newExamBoard() {
    try { 
        clearStatusBar();

        //Variables
        ///Array containing the data pulled from the file system
        var subjects = [];

        ///The file path of the qualification, therefore the location of the index file containing the subjects
        userSession.filePath = encodeURIComponent($("#qualification").val()) + "/" + encodeURIComponent($("#examBoard").val()) + "/";

        ///Variable containing the api to be called for the subjects
        var api = filterAPI(userSession.filePath, false);


        //Updating the page
        ///Awaits the API call and therefore the subjects
        subjects = await callGetAPI(api, "subjects");

        ///Empties the subject input
        $("#subject").empty();

        ///Puts the retrieved subjects into the input box
        subjects.filters.subjects.forEach(element => {
            $("#subject").append(newSelectItem(element.s));
        });

        ///Runs the onChange for the topic box
        newSubject();
    } catch (error) {
        generateErrorBar(error);
    }
}

//Loads new topics from S3 based on the selected subject
async function newSubject() {
    try {
        clearStatusBar();

        //Variables
        ///Array containing the topics pulled from the file system
        var topics = [];

        ///The file path of the topics file
        userSession.filePath = encodeURIComponent($("#qualification").val()) + "/" + encodeURIComponent($("#examBoard").val()) + "/" + encodeURIComponent($("#subject").val()) + "/";

        ///The api to be called to get the topics file for the correct subject
        var api = filterAPI(userSession.filePath, true);


        //Get topics
        ///Awaits the topic file from S3
        topics = await callGetAPI(api, "topics");

        ///Puts the topics into the user session variable
        userSession.topics = topics.filters;

        ///Log the topics, for testing
        //console.log(userSession.topics);

        ///Loads the topics display
        loadTopicDisplay();
    } catch (error) {
        generateErrorBar(error);
    }
}

function loadTopicDisplay() {
    //Variables
    ///Array containing all of the HTML for the topic display
    var topicSelector = [];


    //Display changes 
    ///For each topic section
    userSession.topics.sections.forEach(section => {
        ///Open a topic section div and add a check box for the section
        topicSelector.push(
            "<div class='topic-section'>",
            newThemeBox(section.s, "sections", false)
        );

        ///For each topic in the section 
        userSession.topics[section.s].forEach((topic, i) => {
            ///Add a checkbox for each topic with isChild being true
            topicSelector.push(newThemeBox(topic.t, section.s, true));
        });

        ///Close the section dic
        topicSelector.push("</div>");
    });

    ///Empties the topic selector of any previous or fail data
    $("#topic-select").empty();

    ///Appends the topic selector with all of the HTMl stored in the topic array
    $("#topic-select").append(topicSelector.join(""));

    ///Runs the onClick event for the select all button - makes sure all buttons are not selected and resets the status text
    selectAll("sections");
}

//Generates a checkbox for a theme
///name: the display text and the value of the box
///section: the section that the box belongs to
///isChild: a boolean variable to store whether the box should be indented, as it is a topic not a section
function newThemeBox(name, section, isChild) {
    //Variables
    ///Stores the string for the check box - returned at the end of the function
    var checkBox = "";

    ///A temporary variable containing the class to be given to the box - made from the section and converted into a CSS friendly form
    var boxClass = textToCSS(section);
    
    ///A temporary variable containing the ID for the box - made from the name and converted into CSS friendly syntax
    var boxID = textToCSS(name);


    //Box compilation
    ///Adds the input tye and the class to the string
    checkBox = '<input type="checkbox" class="' + boxClass;

    ///If the box is a child it adds the child box class
    if(isChild){
        checkBox += ' child-box';
    }

    ///Adds the rest of the correctly formatted box
    checkBox += ' check-box" onchange="massSelect(\'' + boxID + '\',\'' + boxClass + '\')" value="' + name + '" id="' + boxID + '"/>';

    ///Adds the label to the box
    checkBox += '<label class="check-box-label" for="' + boxID + '">' + name + '</label><br/>'

    return checkBox;
}

///Converts inputted text into a CSS friendly form
function textToCSS(text){
    //Variables
    ///A temporary variable to store the output - returned at the end of the function
    var output = text;


    //Replacing
    ///Uses regex to remove all invalid characters, excluding spaces
    output = output.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g,"");

    ///Replaces any spaces with dashed
    output = output.replaceAll(" ", "-");

    ///Converts the string to lower case
    output = output.toLowerCase();

    return output;
}

//Selects or deselect every box in the topics section
///boxID: the id of the select all box
function selectAll(boxID){
    try {
        clearStatusBar();

        //Variables
        ///Stores whether the boxes are to be checked or unchecked
        var isSelected = $("#" + boxID).prop("checked");


        //Selection
        ///Changes the checked property of every check box in the topic-select class to the value in isSelected
        $(".topic-select input[type='checkbox']").prop('checked', isSelected);


        //Counting
        ///Resets the number of topics to 0
        userSession.numTopics = 0;

        ///If the boxes were checked
        if(isSelected){
            ///For each section
            userSession.topics.sections.forEach(section => {
                ///Add the number of topics in that section to the number of topics total
                userSession.numTopics += userSession.topics[section.s].length;
            });
        }

        ///Update the display for the number of checked boxes
        updateNumChecked();
    } catch (error) {
        $("#" + boxID).prop("checked", !$("#" + boxID).prop("checked"));

        generateErrorBar(error);
    }
}

//The onClick for a topic check box - handles counting and mass selectors
function massSelect(boxID, boxClass) {
    try {
        clearStatusBar();

        //Variables
        ///The checked property of the box that was selected to run the function - boolean
        var isSelected = $("#" + boxID).prop("checked");
        ///A boolean variable to aid in counting single boxes
        var isChild = true;

        //Counting
        ///For each section
        userSession.topics.sections.forEach(section => {
            ///Use a temporary variable to store the section name in CSS form
            var tempSection = textToCSS(section.s);

            ///If the current box is a mass selector
            if(tempSection === boxID) {
                ///The box is not a child
                isChild = false;

                ///If the box is to be selected
                if(isSelected) {
                    ///For each box with the class of the section selector
                    $("." + boxID).each((index, element) => {
                        ///If they're not checked
                        if(!$(element).prop('checked')){
                            ///Add one to the count
                            userSession.numTopics++;
                        }
                    });
                } else {
                    ///If the box is being deselected then remove the number of boxes in that section from the count
                    userSession.numTopics -= userSession.topics[section.s].length;
                }
            }
        });

        ///If the box is a child
        if(isChild)
        {
            ///if the box is to be selected
            if(isSelected) {
                ///Add one to the count
                userSession.numTopics++;
            } else {
                ///If the box is to be deselected then remove one from the count
                userSession.numTopics--;
            }
        }

        //Display updates
        ///Changes the checked property of every check box with the same class as the box's ID to the value in isSelected
        $("." + boxID).prop('checked', isSelected);

        ///Updates the mass selectors / checks if all child boxes are checked
        updateMassSelectors(isSelected, boxClass);

        ///Update the display for the number of checked boxes
        updateNumChecked();
    } catch (error) {
        $("#" + boxID).prop("checked", !$("#" + boxID).prop("checked"));

        generateErrorBar(error);
    }
}

//Updates the topic header with the number of topics selected
function updateNumChecked() {
    //Display updates
    ///If the number of topics is 0
    if(userSession.numTopics === 0) {
        ///Change the text to ask the user to select a topic
        $("#num-topics-selected").text("Please select one or more topic");
        ///Disable the do questions button
        $(".btn-questions").attr("disabled", "disabled");
    } else {
        ///If there is one or more topic selected show the user how many topics are selected
        $("#num-topics-selected").text(userSession.numTopics + " selected");
        ///Enable the do questions button
        $(".btn-questions").removeAttr("disabled");
    }
}

//Updates the section boxes and the select all box
///isSelected: stores whether the box that was changed was selected or deselected
///boxClass: the class of the box that was checked
function updateMassSelectors(isSelected, boxClass){
    //Variables
    ///Boolean storing whether all of the boxes have been selected
    var isAllSelected = true;

    //Checking and updating
    ///If the box was selected
    if(isSelected) {
        ///For each box with that class
        $("." + boxClass).each(function(index, element) {
            ///If they were not selected
            if(!$(element).prop('checked')){
                ///Then all selected is set to false
                isAllSelected = false;
            }
        });

        ///Updates the relevant mass selector with the value of all selected
        $("#" + boxClass).prop('checked', isAllSelected);

        ///If the box is not a sections box
        if(boxClass != "sections")
        {
            ///Run this function again for the select all button
            updateMassSelectors(true, "sections");
        }
    } else {
        ///If the box was deselected then deselect the section selector and the select all button
        $("#" + boxClass).prop('checked', false);
        $("#sections").prop('checked', false);
    }
}

//The onclick for the start questions button - handles loading the questions from the API and modifying the web page to show the user the question form
async function startQuestions() {
    try {
        clearStatusBar();

        //Disable the button
        ///Prevents double-clicks which cause generation bugs
        $(".btn-questions").attr("disabled", "disabled");


        //Variables
        ///Object to store the parameters for the questions API - the body for the POST interface
        var postBody = {};

        ///Stores whether the user wants the timer to be shown in the user session (only shown since the timer can be used for teacher analytics)
        userSession.isTimerShown = $("#timer-check").prop("checked");

        ///The number of questions to be generated - taken from user input. Stored in the user session and the post body
        userSession.numOfQuestions = $("#numberOfQuestions").val();
        postBody.numOfQuestions = userSession.numOfQuestions;

        ///The location of the questions inside the object store. Customised by user choices, set by user choices. Test data prevents unnecessary API calls
        //userSession.filePath = "iGCSE/Cambridge/Computer Science/";
        userSession.filePath = $("#qualification").val() + "/" + $("#examBoard").val() + "/" + $("#subject").val() + "/";
        postBody.filePath = userSession.filePath;

        ///The topics that the questions may come from - stored in the post body
        postBody.topics = compileTopics();

        ///The full api to be called for questions
        var api = compileQuestionAPI();


        //Data handling
        ///A temporary object to store all of the input from the api, once the data has been returned. Test data prevents unnecessary APi calls whilst having all question types
        //var results = {"questions": {"questions": [{"type": "boxMatch","numAnswers": "3","text": [{"q": "Match the denary with their binary values:"},{"q": "23"},{"q": "00010111"},{"q": "96"},{"q": "01101111"},{"q": "111"},{"q": "01100000"}]},{"type": "boxMatch","numAnswers": "4","text": [{"q": "Match the values to their equivalent:"},{"q": "10KB"},{"q": "16 bits"},{"q": "5MB"},{"q": "8 nibbles"},{"q": "4 bytes"},{"q": "81920 bits"},{"q": "2 bytes"},{"q": "5242880 bytes"}]},{"type": "gapFill","numAnswers": "1","text": [{"q": "The byte is a unit used to measure ______ size."}]},{"type": "calculation","numAnswers": "1","text": [{"q": "11011011 in denary?"}]},{"type": "multipleChoice","numAnswers": "3","text": [{"q": "Which of the following are valid storage units?"},{"q": "Bit"},{"q": "Gigantabyte"},{"q": "Nibble"},{"q": "Nanobyte"},{"q": "Megabyte"}]}],"indexes": ["0022","0023","0016","0008","0013"]}};
        var results = await callPostAPI(api, postBody, "questions");
        
        ///Logging for testing
        //console.log(JSON.stringify(results.questions));

        ///Populating the user session object with the data from the api call
        userSession.questions = results.questions.questions;

        ///For each question 
        for(var i = 0; i < userSession.numOfQuestions; i++)
        {
            ///Apply the index to the question in user session (the object structure is different client side and server side)
            userSession.questions[i].index = results.questions.indexes[i];
        }
        

        //Updating the user display
        displayQuestionScreen();
    } catch (error) {
        //Fixing site changes
        $(".btn-questions").removeAttr("disabled");
        $("#frm-filter").show();
        $("#frm-questions").hide();

        //Error messages
        console.log("error");
        generateErrorBar(error);
    }
}

async function startTestQuestions() {
    try {
        clearStatusBar();

        //Data handling
        userSession.filePath = "iGCSE/Cambridge/Computer Science";

        ///A temporary object to store all of the input from the api, once the data has been returned. Test data prevents unnecessary APi calls whilst having all question types
        var results = {"questions":{"questions":[{"type":"stringMatch","numAnswers":"1","text":[{"q":"What base is binary?"}]},{"type":"stringMatch","numAnswers":"2","text":[{"q":"What are the digits in a binary number?"}]},{"type":"multipleChoice","numAnswers":"3","text":[{"q":"Which of the following are valid storage units?"},{"q":"Bit"},{"q":"Gigantabyte"},{"q":"Nibble"},{"q":"Nanobyte"},{"q":"Megabyte"}]},{"type":"boxMatch","numAnswers":"4","text":[{"q":"Match the values to their equivalent:"},{"q":"5242880MB"},{"q":"5GB"},{"q":"8 bits"},{"q":"5TB"},{"q":"5242880KB"},{"q":"2 bytes"},{"q":"16 bits"},{"q":"2 nibbles"}]},{"type":"multipleChoice","numAnswers":"2","text":[{"q":"Which of these are equivalent to 8KB?"},{"q":"16384 nibbles"},{"q":"1/128 MB"},{"q":"0.128 MB"},{"q":"80008 bits"}]},{"type":"multipleChoice","numAnswers":"1","text":[{"q":"Which of these is 101 in binary?"},{"q":"01000101"},{"q":"01100111"},{"q":"01100101"},{"q":"01100100"}]},{"type":"multipleChoice","numAnswers":"2","text":[{"q":"Which of these are equivalent to one megabyte?"},{"q":"1048576 bytes"},{"q":"1048566 bytes"},{"q":"200000 nibbles"},{"q":"1024 KB"}]},{"type":"boxMatch","numAnswers":"3","text":[{"q":"Match these numbers to their corresponding bases:"},{"q":"00110100"},{"q":"Base 2"},{"q":"69"},{"q":"Base 2"},{"q":"000110000"},{"q":"Base 10"}]},{"type":"calculation","numAnswers":"1","text":[{"q":"11001100 in denary?"}]},{"type":"stringMatch","numAnswers":"2","text":[{"q":"Name two units of memory smaller than a megabyte:"}]},{"type":"multipleChoice","numAnswers":"1","text":[{"q":"How do computers store numbers?"},{"q":"In denary"},{"q":"Using pen and paper"},{"q":"In binary"}]},{"type":"gapFill","numAnswers":"1","text":[{"q":"The byte is a unit used to measure ______ size."}]},{"type":"boxMatch","numAnswers":"4","text":[{"q":"Match the values to their equivalent:"},{"q":"10KB"},{"q":"16 bits"},{"q":"5MB"},{"q":"8 nibbles"},{"q":"4 bytes"},{"q":"81920 bits"},{"q":"2 bytes"},{"q":"5242880 bytes"}]},{"type":"boxMatch","numAnswers":"3","text":[{"q":"Match the denary with their binary values:"},{"q":"23"},{"q":"00010111"},{"q":"96"},{"q":"01101111"},{"q":"111"},{"q":"01100000"}]},{"type":"calculation","numAnswers":"1","text":[{"q":"89 in binary?"}]},{"type":"gapFill","numAnswers":"2","text":[{"q":"Megabytes are each worth ____ kilobytes, which are each worth ____ bytes."}]},{"type":"stringMatch","numAnswers":"1","text":[{"q":"What is the largest number an 8 bit binary number can represent?"}]},{"type":"gapFill","numAnswers":"2","text":[{"q":"The binary number 1010 can be converted into the ______ value __."}]},{"type":"boxMatch","numAnswers":"3","text":[{"q":"Match the binary numbers to their denary equivalents:"},{"q":"00100100"},{"q":"177"},{"q":"11000010"},{"q":"194"},{"q":"10110001"},{"q":"36"}]},{"type":"calculation","numAnswers":"1","text":[{"q":"246 in binary?"}]}],"indexes":["0004","0002","0013","0025","0014","0011","0012","0024","0009","0003","0015","0016","0023","0022","0007","0019","0001","0017","0021","0006"]}};

        ///Populating the user session object with the data from the api call
        userSession.questions = results.questions.questions;

        userSession.numOfQuestions = 20;

        ///For each question 
        for(var i = 0; i < userSession.numOfQuestions; i++)
        {
            ///Apply the index to the question in user session (the object structure is different client side and server side)
            userSession.questions[i].index = results.questions.indexes[i];
        }
        
        userSession.isTimerShown = false;

        //Updating the user display
        displayQuestionScreen();
    } catch (error) {
        window.location.replace(baseURL);

        //Error messages
        generateErrorBar(error);
    }
}

//Loops through the theme check boxes and return the values that are checked 
function compileTopics() {
    //Theme compilation
    ///Array to store the themes, returned at the end of the program
    var themes = [];

    ///For each child box
    $(".child-box").each(function(index, element) {
        ///If the box is checked
        if($(element).prop('checked')){
            ///Push the ID of the box to the array of themes
            themes.push($(element).attr("id"));
        }
    });

    return themes;
}

//Takes in a number of questions and returns a formatted REST api with a POST method to be called for question data 
function compileQuestionAPI() {
    //Variables
    ///The string that will contain the uri, to be returned at the end of the function
    var uri = "";
    

    //Concatenating URI
    ///Takes the api root, the number of questions and the file path and creates a uri for the api
    uri = apiRoot + "/question/recall";

    ///For testing 
    //console.log(uri);

    return uri;
}

//Updates the user's screen to show questions
function displayQuestionScreen() {  
    //Update screen
    ///All HTML indexes use jquery to make the code 4 times neater and easier

    ///Hide the filter form
    $("#frm-filter").hide();
    ///Show the question form
    $("#frm-questions").show();


    //Variable updates
    ///For each question:
    for(var i = 0; i < userSession.numOfQuestions; i++) {
        ///Append a question block to the question bar
        $("#question-bar").append("<div class='question-block' id='question-block" + i + "' onclick='displayQuestion(" + i + ")'>" + (i + 1) + "<div id='question-block-bookmark" + i + "' class='question-bookmark-space'><i class='ion-android-star bookmark' id='bookmark" + i + "'></i></div></div>");
        
        ///Hide the bookmark star of the question block
        $("#bookmark" + i).hide();

        ///Create an array of user answers that corresponds to the number of answers required 
        userSession.questions[i].userAnswers = new Array(parseInt(userSession.questions[i].numAnswers)).fill("");

        ///If the question is a box match question
        if(userSession.questions[i].type === "boxMatch")
        {
            ///Loop for the number of answers
            for(var j = 0; j < userSession.questions[i].numAnswers; j++)
            {
                ///Add the answer text to the user answers array for that question
                userSession.questions[i].userAnswers[j] = userSession.questions[i].text[(j + 1) * 2].q;
            }
        }

        ///Set the timer to 0 
        userSession.questions[i].timer = 0;

        ///Set bookmarked to false
        userSession.questions[i].isBookmarked = false;
    }

    ///Sets current question in the user session to -1, used to skip saving the current question in the page update function
    userSession.currentQuestion = -1;

    ///Displays the first question
    displayQuestion(0);

    ///Starts the timer
    startTimer();
}

//Updates the question form to display a given question
///index: the array index of the question that is to be changed to
function displayQuestion(index) {
    try {
        clearStatusBar();

        //Update features
        ///Change the question title to display the correct number
        $("#question-title").text("Question " + (index + 1));

        ///Update the question text to be the new question
        $("#question-text").text(userSession.questions[index].text[0].q);

        ///Remove the class "selected-block" from all question blocks
        $(".question-block").removeClass("selected-block");

        ///Add the class "selected-block" to the block that corresponds to the current question
        $("#question-block" + index).addClass("selected-block")

        ///Change the user answer console to display the correct question in the correct framework
        displayAnswerConsole(index);


        //Update the current question in the user object
        userSession.currentQuestion = index;


        //Edit button functionality
        ///Make both next and previous buttons work
        $(".btn-prev").removeAttr("disabled");
        $(".btn-next").removeAttr("disabled");

        ///Hide the submit answers button
        $(".ans-button").hide();

        ///If on question 1 
        if(index == 0) {
            //Disable the previous button
            $(".btn-prev").attr("disabled", "disabled");
        } else if (index === userSession.numOfQuestions - 1) { 
            ///If on last question disable the next button
            $(".btn-next").attr("disabled", "disabled");

            ///Show the submit button
            $(".ans-button").show();
        }

        ///Update the bookmark button to the correct state
        updateBookmarkButton();


        //Select the answer box
        $("#answer-box0").focus();
    } catch (error) {
        generateErrorBar(error);
    }
}

//Updates the user answer console, saving the current user answers and displaying the next question
///index: the array index of the question that is to be loaded
function displayAnswerConsole(index) {
    //Saving
    ///If not the very first load
    if(userSession.currentQuestion != -1) {
        ///Store the current answer
        storeAnswer();
    }


    //Loading
    ///Empty out the user input boxes
    $("#user-input").empty();

    ///Depending on the type of question run the correct load question procedure
    switch(userSession.questions[index].type) {
        case "multipleChoice":
            loadMultipleChoice(index);
            break;

        case "boxMatch":
            loadBoxMatch(index);
            break;

        default:
            loadBasicQuestion(index)
            break;
    }
}

//Handles storing a user answer 
function storeAnswer() {
    //Depending on the type of question run the correct save answer procedure
    switch(userSession.questions[userSession.currentQuestion].type) {
        case "multipleChoice":
            storeMultipleChoice();
            break;

        case "boxMatch":
            storeBoxMatch();
            break;

        default:
            storeBasicQuestion();
            break;
    }
}

//Stores the user answers for a multiple choice question
function storeMultipleChoice() {
    //Store answer
    ///Select user answer array for the current question and replace it with an empty array
    userSession.questions[userSession.currentQuestion].userAnswers = [];

    ///For each multiple choice box
    $(".multiple-choice-box").each((index, element) => {
        ///If the box is checked
        if($(element).prop('checked')){
            ///Push the value to the user answers array
            userSession.questions[userSession.currentQuestion].userAnswers.push($(element).val());
        }
    });
}

//Stores the user answers for a box match question
function storeBoxMatch() {
    //Store answer
    ///Store the text in each of the drag boxes in the user answer array
    for(var i = 0; i < userSession.questions[userSession.currentQuestion].userAnswers.length; i++) { 
        userSession.questions[userSession.currentQuestion].userAnswers[i] = $("#answer-box" + i).text().trim();
    }
}

//Stores the user answers for a string match / standard question
function storeBasicQuestion() {
    //Store answer
    ///Store the text in each of the answer boxes in the user answer array
    for(var i = 0; i < userSession.questions[userSession.currentQuestion].userAnswers.length; i++) { 
        userSession.questions[userSession.currentQuestion].userAnswers[i] = $("#answer-box" + i).val().trim();
    }
}

//Loads the display for a multiple choice question
///index: the array index for the question to be loaded
function loadMultipleChoice(index) {
    //Load question
    ///For each prompt
    for(var i = 1; i < userSession.questions[index].text.length; i++)
    {
        ///A temporary variable to store the current prompt
        var tempText = userSession.questions[index].text[i].q;

        ///Append the check box and it's label to the user input column
        $("#user-input").append('<input type="checkbox" class="multiple-choice-box check-box" value="' + tempText + '" id="answer-box' + (i - 1) + '"/>');
        $("#user-input").append('<label class="answer-box-label" for="answer-box' + (i - 1) + '">' + tempText + '</label><br>');

        ///If the question was previously checked by a user
        if(userSession.questions[index].userAnswers.includes(tempText)){
            ///Check the box that was just added
            $("#answer-box" + (i - 1)).prop('checked', true);
        }
    }
}

//Loads the display for a box match question
///index: the array index for the question to be loaded
function loadBoxMatch(index) {
    //Variables
    ///Array to store the box match display
    var boxMatch = [];

    ///The number of rows that need to be generated for the box match
    var loopLength = (userSession.questions[index].text.length - 1)/2;


    //Load question
    ///Open the row and then the column for the static prompts
    boxMatch.push(
        '<div class="row">',
        '<div class="col-xs-6">'
    );

    ///For each prompt
    for(var i = 1; i < loopLength + 1; i++)
    {
        ///Generate a static question prompt
        boxMatch.push('<label class="drag-label">' + userSession.questions[index].text[(2 * i - 1)].q + '</label><br/>');
    }

    ///Close the column and open a new column, along with the drag list
    boxMatch.push(
        '</div>',
        '<div class="col-xs-6">',
        '<div class="drag-list">'
    );

    ///For each answer prompt
    for(var i = 0; i < loopLength; i++)
    {
        ///Generate a drag item with a label and the icon
        boxMatch.push('<div class="drag-item" draggable="true"><label id="answer-box' + i + '">' + userSession.questions[index].userAnswers[i] + '</label><i class="ion-drag drag-symbol"></i></div>');
    }

    ///Close all remaining divs
    boxMatch.push(
        '</div>',
        '</div>',
        '</div>'
    );

    ///Append the whole box match to the user screen
    $("#user-input").append(boxMatch.join(""));


    //Initialise the drag and drop functions
    setTimeout(() => initDrag(), 0);
}

//Loads the display for a string match / standard question
///index: the array index for the question to be loaded
function loadBasicQuestion(index) {
    //Load question
    ///For each answer
    for(var i = 0; i < parseInt(userSession.questions[index].numAnswers); i++){
        ///Add an answer box
        $("#user-input").append("<input class='form-control' id='answer-box" + i + "' type='text'></input>");
        ///Update the answer box with the current user answer for the new question
        $("#answer-box" + i).val(userSession.questions[index].userAnswers[i]);
    }
}

//Starts up the timer
function startTimer() {
    //Start timer
    ///Sets the start of the timer interval to now
    userSession.timerStart = Date.now();

    ///Sets the timer to the user session object. Allows easy stopping
    userSession.timer = setInterval(() => {
        ///setInterval is not accurate and starts to drift over time, hance the interval system instead of a basic incrementer
        ///Adds the difference since the last timer interval to the current question's timer
        userSession.questions[userSession.currentQuestion].timer += Date.now() - userSession.timerStart;

        ///Sets the start of the timer interval to the current time
        userSession.timerStart = Date.now();

        ///If the timer is shown
        if(userSession.isTimerShown){
            ///Update the shown answer
            $("#question-timer").text(timerToText(userSession.questions[userSession.currentQuestion].timer));
        }
    }, 500);
}

//Converts a number of milliseconds into a user-friendly string
///input: the number (in milliseconds) to be converted
function timerToText(input) {
    //Variables
    ///The number of milliseconds to be converted
    var timer = input;

    ///The string to be returned at the end of the function
    var output = "";


    //Calculations
    ///base in milliseconds .'. 1
    ///seconds = 1 * 1000 .'. MOD 1000
    ///minutes = 1000 * 60 .'. MOD 60,000
    ///hours = 60,000 * 60 .'. MOD 3,600,000


    //Display handling
    ///If the timer contains hours
    if(timer % 3600000 != timer){
        ///Add an integer number of hours to the string
        output += Math.floor(timer / 3600000) + "h ";

        ///Remove thr hours from the timer
        timer = timer % 3600000;
    }

    ///If the timer contains minutes
    if(timer % 60000 != timer){
        ///Add an integer number of minutes to the string
        output += Math.floor(timer / 60000) + "m ";

        ///Remove thr hours from the timer
        timer = timer % 60000;
    }

    ///Add an integer number of seconds to the string
    output += Math.floor(timer / 1000) + "s ";

    return output;
}

//Bookmark a question for the user
function bookmarkQuestion(){
    try {
        //Bookmark question
        ///If the current question is bookmarked
        if(userSession.questions[userSession.currentQuestion].isBookmarked) {
            ///Set the question to not bookmarked
            userSession.questions[userSession.currentQuestion].isBookmarked = false;

            ///Hide the bookmark star on the question block
            $("#bookmark" + userSession.currentQuestion).hide();
        } else {
        ///If the current question is not bookmarked set the question to bookmarked
            userSession.questions[userSession.currentQuestion].isBookmarked = true;

            ///Show the bookmark star on the question block
            $("#bookmark" + userSession.currentQuestion).show();
        }

        ///Focus on the answer box
        $("#answer-box0").focus();

        ///Update the bookmark button
        updateBookmarkButton();
    } catch (error) {
        generateErrorBar(error);
    }
}

//Updates the bookmark button, particularly the symbol
function updateBookmarkButton() {
    //Update the button
    ///If the question is bookmarked
    if(userSession.questions[userSession.currentQuestion].isBookmarked) {
        ///Empty the contents of the button
        $("#btn-bookmark").empty();

        ///Add the text and a filled in star
        $("#btn-bookmark").append('Bookmark');
        $("#btn-bookmark").append('<i class="ion-android-star bookmark"></i>');
    } else {
        ///If the question isn't bookmarked empty the contents of the button 
        $("#btn-bookmark").empty();

        ///Add the text and a star outline
        $("#btn-bookmark").append('Bookmark');
        $("#btn-bookmark").append('<i class="ion-android-star-outline bookmark"></i>');
    }
}

//Select the previous question
function selectPrevQuestion() {
    try {
        clearStatusBar();

        //Change question
        ///Find out the current question
        var index = userSession.currentQuestion;

        if(index > 0) {
            ///If you can go to a previous question then do so. Backup checking in case button doesn't disable correctly
            displayQuestion(index - 1);
        }
    } catch (error) {
        generateErrorBar(error);
    }
}

//Select the next question
function selectNextQuestion() {
    try {
        clearStatusBar();

        //Change question
        ///Find out the current question
        var index = userSession.currentQuestion;

        if(index < userSession.numOfQuestions - 1) {
            ///If you can go to a nexy question then do so. Backup checking in case button doesn't disable correctly
            displayQuestion(index + 1);
        }
    } catch (error) {
        generateErrorBar(error);
    }
}

//The onclick for the submit answers button - handles loading the answers from the API, marking the questions and modifying the web page to show the user the answer form
async function submitAnswers() {
    try {
        clearStatusBar();

        //Immediate actions
        ///Disables the submit button to prevent duplication
        $(".btn-submit").attr("disabled", "disabled");

        ///Stops the timer, prevents unfair recorded time
        endTimer();

        //Variables
        ///Makes sure the current user change is recorded
        storeAnswer();

        await getAnswers();

        //Answer handling
        ///Marking the answers
        markAnswers();

        if(!sessionStorage.getItem("isGuest")) {
            ///Sends the question history to the server
            await sendQuestionHistory();
        }

        ///Displaying the answers form
        displayAnswerScreen();
    } catch (error) {
        $(".btn-submit").removeAttr("disabled");
        $("#frm-questions").show();
        $("#frm-answers").hide();

        generateErrorBar(error);
    }
}

async function getAnswers() {
    if(sessionStorage.getItem("isGuest")) {
        var response = {"answers":[[{"a":"2"}],[{"a":"0"},{"a":"1"}],[{"a":"Nibble"},{"a":"Bit"},{"a":"Megabyte"}],[{"a":"5TB"},{"a":"2 nibbles"},{"a":"5GB"},{"a":"2 bytes"}],[{"a":"16384 nibbles"},{"a":"1/128 MB"}],[{"a":"01100101"}],[{"a":"1024 KB"},{"a":"1048576 bytes"}],[{"a":"Base 2"},{"a":"Base 10"},{"a":"Base 2"}],[{"a":"204"}],[{"a":"bit"},{"a":"nibble"},{"a":"byte"},{"a":"kilobyte"}],[{"a":"In binary"}],[{"a":"memory"},{"a":"storage"}],[{"a":"81920 bits"},{"a":"5242880 bytes"},{"a":"8 nibbles"},{"a":"16 bits"}],[{"a":"00010111"},{"a":"01100000"},{"a":"01101111"}],[{"a":"01011001"}],[{"a":"1024"},{"a":"1024"}],[{"a":"255"}],[{"a":"denary"},{"a":"10"}],[{"a":"36"},{"a":"194"},{"a":"177"}],[{"a":"11110110"}]]};
    } else {
        ///The full api to be called for the correct answers
        var api = compileAnswerAPI();

        ///A temporary object to store the results from the api call
        var response = await callGetAPI(api, "answers");
    }

    ///For each question 
    for(var i = 0; i < userSession.numOfQuestions; i++)
    {
        ///Add an array of correct answers to the selected question
        userSession.questions[i].correctAnswers = [];

        ///For each correct answer for this question
        for(var j = 0; j < response.answers[i].length; j++)
        {
            ///Push it to the correct answers array 
            userSession.questions[i].correctAnswers.push(response.answers[i][j].a);
        }

        ///Populates the user session object with an initialised array containing whether each question is correct
        userSession.questions[i].isCorrect = false;
    }
}

//End the timer and calculates the total timer for the whole set
function endTimer() {
    //Ends the timer
    clearInterval(userSession.timer);

    //Totals the timer
    ///Initialises total time to 0
    userSession.totalTime = 0;

    ///For each question
    userSession.questions.forEach((element) => {
        ///Add the timer for the current question to the total time
        userSession.totalTime += element.timer;
    });
}

//A function that uses the user session object to make a uri for the answers api
function compileAnswerAPI() {
    //URI generation
    ///A variable to store the uri generated by the function. To be returned
    var uri = "";
    
    ///Loading the variable with the api root, the correct resource and the file path
    uri = apiRoot + "/question/answer-recall?filePath=" + userSession.filePath;

    ///Loads the uri with the question indexes. Uses multiQueryStringParameters instead of the standard queryStringParameters, hence the repetition of index assignments instead of square brackets
    for (var i = 0; i < userSession.numOfQuestions; i++) {
        uri += "&indexes=" + userSession.questions[i].index;
    }

    ///For testing
    //console.log(uri);

    return uri;
}

//Compares the user answers to the correct answers
function markAnswers() {
    //Variables
    ///Populates user session with a number containing the number of correct answers
    userSession.numCorrect = 0;

    //Marking
    ///For each question
    for (var i = 0; i < userSession.numOfQuestions; i++) {
        ///If the question isn't empty and the user answers array contains something
        if(userSession.questions[i].userAnswers.length != 0)
        {
            ///Set a boolean flag variable to true - represents whether the user has gotten the whole question correct. Defaults to correct
            var allCorrect = true;

            ///Depending on the type of question
            switch(userSession.questions[i].type)
            {
                case "boxMatch":
                    ///For each answer
                    for(var j = 0; j < userSession.questions[i].userAnswers.length; j++)
                    {
                        ///If the correct answers don't contain the user answer 
                        ///Standard for string match questions
                        if(userSession.questions[i].correctAnswers[j] != userSession.questions[i].userAnswers[j]) {
                            ///The user got the question wrong
                            allCorrect = false;
                        }
                    }
                    break;
            
                case "multipleChoice":
                    if(userSession.questions[i].userAnswers.length === userSession.questions[i].correctAnswers.length)
                    {
                        ///For each user answer
                        for(var j = 0; j < userSession.questions[i].userAnswers.length; j++)
                        {
                            ///If the correct answers doesnt contain the user answer
                            ///Multiple choice is segregated due to the lack of case sensitivity errors. Answers are stored the same as the question prompts are displayed
                            if(!userSession.questions[i].correctAnswers.includes(userSession.questions[i].userAnswers[j])) {
                                ///The user got the question wrong
                                allCorrect = false;
                            }
                        }      
                    } else {
                        allCorrect = false;
                    }
                    break;     
                default:
                    ///For each answer
                    for(var j = 0; j < userSession.questions[i].userAnswers.length; j++)
                    {
                        ///If the correct answers don't contain the user answer 
                        ///Standard for string match questions
                        if(!userSession.questions[i].correctAnswers.includes(userSession.questions[i].userAnswers[j].toLowerCase())) {
                            ///The user got the question wrong
                            allCorrect = false;
                        }
                    }
                    break;
            }

            ///If the user got the question completely correct
            if(allCorrect) {
                ///Update the user session to show that this question is correct
                userSession.questions[i].isCorrect = true;
                userSession.numCorrect++;
            }
        }
    }
}

//Displays/generates the answer form
function displayAnswerScreen() {
    //Constants
    ///The score boundary for red text
    const lowScore = 0.33;
    ///The score boundary for amber text
    const mediumScore = 0.66;

    //Feature updates
    ///Hides the question form
    $("#frm-questions").hide();
    ///Shows the answer form
    $("#frm-answers").show();

    ///Displays the number of correct questions
    $("#user-score-value").text(userSession.numCorrect);
    ///Displays the total number of questions
    $("#total-score-value").text(userSession.numOfQuestions);

    //Colour co-ordination
    if(userSession.numCorrect/userSession.numOfQuestions <= lowScore) {
        ///If below red boundary then show red text and corresponding message
        $("#user-score-value").addClass("red-text");
        $("#user-message").addClass("red-text");
        $("#user-message").text("Good Effort!");
    } else if(userSession.numCorrect/userSession.numOfQuestions <= mediumScore) {
        ///Else if below amber boundary display amber text and corresponding message
        $("#user-score-value").addClass("amber-text");
        $("#user-message").addClass("amber-text");
        $("#user-message").text("Good Results!");
    } else {
        ///Else use green text
        $("#user-score-value").addClass("green-text");
        $("#user-message").addClass("green-text");
        if(userSession.numCorrect/userSession.numOfQuestions === 1)
        {
            ///If 100% display special message
            $("#user-message").text("Brilliant!");
        } else {
            ///Else use standard green text message
            $("#user-message").text("Well Done!");
        }
    }

    //Form generation
    ///For each question add an answer block to the page
    for (var i = 0; i < userSession.numOfQuestions; i++) {
        $("#answer-container").append(buildAnswerDiv(i));
    }
}

//Generates an answer block for a given question
///index: the index for the question that the block is being generated for
function buildAnswerDiv(index) {
    //Variables
    ///A string array for each line of the box. To be combined then returned at the end of the function.
    var answerDiv = [];

    ///The icon inside the header bar - standard is red cross
    var icon = 'ion-close-round red-text symbol';

    ///The part of the header bar that contains the timer - stored in a variable since the contents are determined by user input
    var timerLine = '';

    ///The part of the header bar that contains the bookmark information and flagging - stored in a variable since the contents are determined by user input
    var bookmarked = '';


    //Variable selection
    ///If the user got the question correct
    if(userSession.questions[index].isCorrect){
        ///Set the icon to the green tick
        icon = 'ion-checkmark-round green-text symbol'
    }

    ///If the user asked to see their timer
    if(userSession.isTimerShown){
        ///Populate the timer line with the timer value
        timerLine = '<div class="col-xs-5 question-time">' + timerToText(userSession.questions[index].timer) + '</div>';
    } else {
        ///If the user doesn't want to see the timer 
        timerLine = '<div class="col-xs-5 question-time"></div>';
    }

    if(userSession.questions[index].isBookmarked) {
        bookmarked = '<i class="ion-android-star bookmark"></i>';
    }


    //Div generation
    ///A push command for every line
    answerDiv.push(
        ///Whole box styling
        '<div class="question-box" id="question-box' + index + '">',
            ///Header bar - controls collapse section and is always shown
            '<div class="row header-bar" id="header-bar' + index + '" data-toggle="collapse" data-target="#answer-bar' + index + '" aria-expanded="false" aria-controls="answer-bar' + index + '">',
                ///Question number
                '<div class="col-xs-1 question-number">' + (index + 1) + bookmarked + '</div>',
                ///Question id - converts question id into a subject specific format
                '<div class="col-xs-2 question-id">' + convertQuestionIndex(index) + '</div>',
                timerLine,
                '<div class="col-xs-2"><i class="' + icon + '"></i></div>',
                ///Both the up and down arrows - correct arrow for the current state is shown by CSS styling
                '<div class="col-xs-2"><i class="ion-android-arrow-dropdown-circle symbol"></i><i class="ion-android-arrow-dropup-circle symbol"></i></div>',
            '</div>',
            ///Collapsed section
            '<div class="answer-bar collapse" id="answer-bar' + index + '">',
                '<div class="row">',
                    '<div class="col-xs-12">',
                        ///The question text TODO multi question etc                  
                        '<div class="question-text" id="question-text' + index + '">' + userSession.questions[index].text[0].q + '</div>',
                    '</div>',
                '</div>',
                '<div class="marked-answers">',
                    '<div class="row">',
                        '<div class="col-xs-12">',
                            ///User answer(s)
                            '<p>You answered:</p>',
                            ///Determined by a function, depending on the type of question
                            displayAnswerText(index, userSession.questions[index].userAnswers, "user-answer"),
                        '</div>',
                    '</div>',
                    '<div class="row">',
                        '<div class="col-xs-12">',
                            ///Correct answer(s)
                            '<p>Correct answer(s):</p>',
                            displayAnswerText(index, userSession.questions[index].correctAnswers, "marked-answer"),
                        '</div>',
                    '</div>',
                '</div>', 
            '</div>',
        '</div>'
    );

    ///Combines every element of the array into one string and returns it
    return answerDiv.join("");
}

//Converts a generic file name into a subject specific file name - puts three letters in the front for the corresponding file path elements
///index: the array index of the question to be converted
function convertQuestionIndex(index) {
    //Variables
    ///The output, returned at the end of the function, stores the file index
    var fileIndex = "";

    ///The location of the files in the object store - stores locally to allow manipulation 
    var filePath = userSession.filePath;


    //Index conversion
    ///For each filter
    for(var i = 0; i < 3; i++)
    {
        ///Add the first character of the file path to the index
        fileIndex += filePath[0];

        ///Removes the front element of the file path and the corresponding slash
        filePath = filePath.substring(filePath.indexOf("/") + 1);
    }

    ///Add the file name to the index
    fileIndex += userSession.questions[index].index;

    return fileIndex;
}

//Choose the correct function to display the answer for either the correct answers or the user answers for the answer screen
///index: the array index of the question to be displayed
///answerSet: the set of texts to be displayed either the correct answers or the user answers
///idStem: the base of the answer box ids
function displayAnswerText(index, answerSet, idStem) {
    //Variable
    ///The output of the function, returned at the end
    var output = "";


    //Display answer
    ///Depending on the type of question load an answer set in the correct format for the answer screen
    switch (userSession.questions[index].type){
        case "multipleChoice":
            output = displayMultipleChoice(index, answerSet, idStem);
            break;

        case "boxMatch":
            output = displayBoxMatch(index, answerSet, idStem);
            break;

        default:
            output = displayBasicQuestion(index, answerSet, idStem);
            break;
    }

    return output;
}

//Displays a multiple choice answer set for the answer screen
///index: the array index of the question to be displayed
///answerSet: the set of texts to be displayed either the correct answers or the user answers
///idStem: the base of the answer box ids
function displayMultipleChoice(index, answerSet, idStem) {
    //Variables
    ///An array to store all of the HTMl for the display - returned from the function as a joined string
    var multChoice = [];

    //Generate display
    ///For each question prompt
    for(var i = 1; i < userSession.questions[index].text.length; i++)
    {
        ///Set a temporary variable containing the prompt
        var tempText = userSession.questions[index].text[i].q;

        ///Push the beginning of a check box to the display
        multChoice.push('<input type="checkbox" class="multiple-choice-box check-box"');

        ///If the prompt is in the answer set
        if(answerSet.includes(tempText))
        {
            ///Check the box
            multChoice.push(' checked="true" ');
        }

        ///Finish the check box, including the disabled attribute 
        multChoice.push('value="' + tempText + '" id="' + idStem + index + '.' + (i - 1) + '"disabled/>');

        ///Add a label to the check box
        multChoice.push('<label class="answer-box-label" for="' + idStem + index + '.' + (i - 1) + '">' + tempText + '</label><br/>');
    }

    return multChoice.join("");
}

//Displays a box match answer set for the answer screen
///index: the array index of the question to be displayed
///answerSet: the set of texts to be displayed either the correct answers or the user answers
///idStem: the base of the answer box ids
function displayBoxMatch(index, answerSet, idStem) {
    //Variables
    ///An array to store all of the HTMl for the display - returned from the function as a joined string
    var boxMatch = [];

    ///The number of rows that need to be generated for the box match
    var loopLength = (userSession.questions[index].text.length - 1)/2;


    //Generate display
    ///Open the row and then the column for the static prompts
    boxMatch.push(
        '<div class="row">',
        '<div class="col-xs-6">'
    );

    ///Display the static prompts
    for(var i = 1; i < loopLength + 1; i++)
    {
        boxMatch.push('<label class="drag-label">' + userSession.questions[index].text[(2 * i - 1)].q + '</label><br/>');
    }

    ///Close the static prompt list and and open the dynamic list (disabled now)
    boxMatch.push(
        '</div>',
        '<div class="col-xs-6">',
    );

    ///Display the disabled dynamic prompts
    for(var i = 0; i < loopLength; i++)
    {
        boxMatch.push('<div class="drag-label"><label id="' + idStem + index + "." + i + '">' + answerSet[i] + '</label></div>');
    }

    ///Close any remaining divs
    boxMatch.push(
        '</div>',
        '</div>'
    );

    return boxMatch.join("");
}

//Displays a string match / standard answer set for the answer screen
///index: the array index of the question to be displayed
///answerSet: the set of texts to be displayed either the correct answers or the user answers
///idStem: the base of the answer box ids
function displayBasicQuestion(index, answerSet, idStem) {
    //Variables
    ///An array to store all of the HTMl for the display - returned from the function as a joined string
    var answerBox = [];


    //Generate display
    ///For each question prompt
    for(var i = 0; i < answerSet.length; i++){
        ///Push an answer box with an answer from the answer set
        answerBox.push('<input class="form-control" id="' + idStem + index + "." + i + '" type="text" readonly value="' + answerSet[i] + '"></input>');
    }

    return answerBox.join("");
}

//Sends user data to the question history storage
async function sendQuestionHistory() {
    ///The api to send the data
    const api = apiRoot + "/question/history/store";

    //For every question
    for (var i = 0; i < userSession.numOfQuestions; i++) {
        try{
            //Variables
            ///The data to be posted to the system
            var postBody = compileQuestionHistory(i);

            //Data sending
            ///Sending the data to the system
            await callPostAPI(api, postBody, "question history", false);
        } catch (e) {
            //Hide any errors - a mild gap in logging is understandable and not-necessary for reporting. Retry once but no more than once
            try{
                var postBody = compileQuestionHistory(i);
    
                await callPostAPI(api, postBody, "question history", false);
            } catch (e) {

            }
        }
    }
}

//Compile the data form a certain question into a form that can be sent to the system
///index: the array index of the question that is to have it's data compiled
function compileQuestionHistory(index) {
    //Data compilation
    ///Creating the object that will be used
    var questionHistory = {};

    ///Collating the user's answers into a string
    questionHistory.userAnswers = JSON.stringify(userSession.questions[index].userAnswers);

    ///The current time
    questionHistory.timestamp = getTimestamp();

    ///The time spent on the current question
    questionHistory.timeSpent = userSession.questions[index].timer;

    ///The data required to work out the ID for the current question
    questionHistory.questionID = {};
    questionHistory.questionID.fileName = userSession.questions[index].index;
    questionHistory.questionID.filePath = userSession.filePath;

    ///The data required to get a user's ID
    questionHistory.userID = {};
    questionHistory.userID.email = userSession.auth.email;
    
    ///The data required to get the current assignment's ID - or blank if not an assignment
    questionHistory.assignmentID = getAssignment();

    ///Whether or not the user got the question correct
    questionHistory.isCorrect = userSession.questions[index].isCorrect;

    return questionHistory;
}

//Gets the current timestamp in a format that the backend finds friendly
function getTimestamp() {
    //Timestamp
    ///The current time as an ISO string - e.g. '2021-11-03T15:33:31.424Z'
    var now = new Date().toISOString();

    ///Cutting off the Z
    return now.substring(0, 23);
}

//Gets the ID of the current assignment
function getAssignment() {
    //Get ID
    ///Create a return variable - null in case of no assignment
    var assignmentID = "";
    
    ///If there is an existing assignment ID - if this is an assignment
    if(userSession.assignmentID) {
        ///Set thereturn variable to the assignment ID
        assignmentID = userSession.assignmentID;
    }

    return assignmentID;
}

//Runs when the code loads - the timeout buffers until the full page loads
///Runs the initialise function in case more than one function call is needed
window.onload = function(){
   setTimeout(initialise(), 1);
};

//Runs when the page loads
async function initialise(){
    //If the user is a guest
    if(sessionStorage.getItem("isGuest")) {
        //Set the loader to 1 (on by default)
        userSession.loaderVal = 1;

        //Function calls
        ///Run the guest access questions - no API calls
        startTestQuestions();

        ///Hide the loader
        hideLoader();
    } else {
        //Set the loader to 1 (on by default)
        userSession.loaderVal = 1;

        //Function calls
        ///Initialise the user
        initialiseAuth(); 

        ///Loads the qualification values into the input box
        loadQualification();
    }
}